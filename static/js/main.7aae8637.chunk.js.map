{"version":3,"sources":["hooks/useKeyPress.ts","model/Grid.ts","physics/Movement.ts","Score.tsx","Controls.tsx","TetrisGrid.tsx","hooks/useInterval.ts","shapes/Generator.ts","shapes/Square.ts","shapes/Line.ts","shapes/HockeyStick.ts","shapes/sShape.ts","shapes/jShape.ts","shapes/zShape.ts","shapes/tShape.ts","Footer.tsx","Overlay.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["useKeyPress","targetKey","useState","keyPressed","setKeyPressed","useEffect","downHandler","key","upHandler","window","addEventListener","removeEventListener","CellStatus","Result","initEmptyGrid","width","height","grid","row","getEmptyRow","col","getEmptyCell","color","status","EMPTY","getGridStateForShape","shape","positionIndex","shapeRow","shapeCol","gridWidth","gridHeight","newShapeGrid","kind","FAILURE","gridState","shapePosition","positions","length","currentCellRowIndex","currentCellColIndex","FULL","SUCCESS","mergeShapeIntoGrid","mergedGridState","isRowComplete","canShapeMoveDown1Step","console","log","doesShapeCollideWithAnother","Score","props","className","score","level","Controls","rotateShape","moveLeft","moveDown","moveRight","onClick","role","aria-label","TetrisGrid","shapes","gameOver","levelComplete","isRunning","setIsRunning","setScore","setGridState","shapeIndex","setShapeIndex","activeShapePositionIndex","setActiveShapePositionIndex","activeShapeRow","setActiveShapeRow","Math","floor","activeShapeCol","setActiveShapeCol","getShapeGridResult","activeShapeGridState","runGameStep","isGameOver","updatedGridState","areThereAnyCompleteRows","rowRemovalResult","gridWithCompleteRowsReplaced","completeRowCount","unshift","push","removeCompleteRows","nextShapeIndex","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","max","getGameLoopSpeedForLevel","arrowLeftKeyPressed","arrowRightKeyPressed","arrowUpKeyPressed","arrowDownKeyPressed","canShapeMoveLeft","lastColIndex","canShapeMoveRight","newPositionIndex","proposedShapeGridResult","map","rowIndex","cell","cellIndex","style","backgroundColor","knownShapes","name","colors","getRandomShapes","count","i","randomShape","random","randomColor","getNumberOfShapesForLevel","Footer","href","target","Overlay","display","active","children","App","setLevel","setShapes","showOverlay","setShowOverlay","showGameOver","setShowGameOver","nextLevel","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.7aae8637.chunk.js","sourcesContent":["import { useEffect, useState } from \"react\";\n\n// useKeyPress - from https://usehooks.com/useKeyPress/\nexport function useKeyPress(targetKey: string) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  // Add event listeners\n  useEffect(() => {\n    // If pressed key is our target key then set to true\n    function downHandler({ key }: KeyboardEvent) {\n      if (key === targetKey) {\n        setKeyPressed(true);\n      }\n    }\n\n    // If released key is our target key then set to false\n    const upHandler = ({ key }: KeyboardEvent) => {\n      if (key === targetKey) {\n        setKeyPressed(false);\n      }\n    };\n\n    window.addEventListener(\"keydown\", downHandler);\n    window.addEventListener(\"keyup\", upHandler);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener(\"keydown\", downHandler);\n      window.removeEventListener(\"keyup\", upHandler);\n    };\n  }, [targetKey]); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n}\n","import { Shape, ShapeMatrix } from \"../shapes/Shape\";\n\n// Grid related model types\n\nexport enum CellStatus {\n  EMPTY,\n  FULL,\n}\n\nexport interface GridCellState {\n  color: string;\n  status: CellStatus;\n}\n\n// The entire grid: a 2d array\nexport type GridState = GridCellState[][];\n\nexport enum Result {\n  SUCCESS,\n  FAILURE,\n}\n\nexport interface NewGridStateResult {\n  kind: Result;\n  gridState: GridState;\n}\n\n// Return 2d array of GridCellState items\nexport function initEmptyGrid(width: number, height: number): GridState {\n  const grid: Array<Array<GridCellState>> = [];\n  for (let row = 0; row < height; row++) {\n    grid[row] = getEmptyRow(width);\n  }\n  return grid;\n}\n\nexport function getEmptyRow(width: number): GridCellState[] {\n  const row = [];\n  for (let col = 0; col < width; col++) {\n    row[col] = getEmptyCell();\n  }\n  return row;\n}\n\nexport function getEmptyCell(): GridCellState {\n  return {\n    color: \"white\",\n    status: CellStatus.EMPTY,\n  };\n}\n\nexport function getGridStateForShape(\n  shape: Shape,\n  positionIndex: number,\n  shapeRow: number,\n  shapeCol: number,\n  gridWidth: number,\n  gridHeight: number\n): NewGridStateResult {\n  const newShapeGrid = initEmptyGrid(gridWidth, gridHeight);\n\n  // Shape can be undefined, if the level has not started yet\n  if (!shape) {\n    return {\n      kind: Result.FAILURE,\n      gridState: newShapeGrid,\n    };\n  }\n\n  // Choose the shape's position (this is how rotation is implemented)\n  const shapePosition: ShapeMatrix = shape.positions[positionIndex % shape.positions.length];\n\n  // Assumes grid will always be big enough for the shape!\n  // shapePosition.length is the HEIGHT of the new shape\n  for (let row = 0; row < shapePosition.length; row++) {\n    for (let col = 0; col < shapePosition[row].length; col++) {\n      const currentCellFlag = shapePosition[row][col];\n      if (currentCellFlag === 1) {\n        // Set the grid cell to ON!\n        const currentCellRowIndex = row + shapeRow;\n        const currentCellColIndex = col + shapeCol;\n        // It's possible that - due to rotation - a cell could be attempted to be set which is\n        // \"out of bounds\" of the grid. Return a failure in this case\n        if (currentCellRowIndex >= newShapeGrid.length || currentCellColIndex >= newShapeGrid[row].length) {\n          return {\n            kind: Result.FAILURE,\n            gridState: newShapeGrid,\n          };\n        }\n        newShapeGrid[currentCellRowIndex][currentCellColIndex] = {\n          color: shape.color || \"1\",\n          status: CellStatus.FULL,\n        };\n      }\n    }\n  }\n  return {\n    kind: Result.SUCCESS,\n    gridState: newShapeGrid,\n  };\n}\n\nexport function mergeShapeIntoGrid(shape: GridState, grid: GridState): GridState {\n  const mergedGridState: GridState = [];\n  for (let row = 0; row < shape.length; row++) {\n    // Copy the current row to the merged grid\n    mergedGridState[row] = [...grid[row]];\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY) {\n        mergedGridState[row][col] = { ...shape[row][col] };\n      }\n    }\n  }\n  return mergedGridState;\n}\n\nfunction isRowComplete(row: GridCellState[]): boolean {\n  for (let col = 0; col < row.length; col++) {\n    if (row[col].status === CellStatus.EMPTY) {\n      // Short-circuit as soon as we find a single empty cell\n      return false;\n    }\n  }\n  // Made it through the entire row without finding an empty cell, so this row is complete!\n  return true;\n}\n\nexport function areThereAnyCompleteRows(grid: GridState): boolean {\n  // Search up from the bottom, which is where the complete rows are likely to be found\n  for (let row = grid.length - 1; row >= 0; row--) {\n    if (isRowComplete(grid[row])) {\n      // Complete row found!\n      return true;\n    }\n  }\n  // Did not find any complete rows\n  return false;\n}\n\ninterface RowRemovalResult {\n  grid: GridState;\n  completeRowCount: number;\n}\n\nexport function removeCompleteRows(grid: GridState): RowRemovalResult {\n  const gridWithCompleteRowsReplaced = [];\n  let completeRowCount = 0;\n  for (let row = 0; row < grid.length; row++) {\n    if (isRowComplete(grid[row])) {\n      // Complete row found!\n      // Unshift an empty row instead of the current grid row\n      completeRowCount++;\n      gridWithCompleteRowsReplaced.unshift(getEmptyRow(grid[row].length));\n    } else {\n      // This row is not complete: add it as-is to the end of gridWithCompleteRowsReplaced\n      gridWithCompleteRowsReplaced.push([...grid[row]]);\n    }\n  }\n  return {\n    completeRowCount,\n    grid: gridWithCompleteRowsReplaced,\n  };\n}\n","import { GridState, CellStatus, getEmptyRow, getEmptyCell } from \"../model/Grid\";\n\n// Can this shape move down 1 step? Or, has it reached the bottom of the grid, or another shape?\nexport function canShapeMoveDown1Step(shape: GridState, grid: GridState): boolean {\n  // Find each active cell of the shape. Check for an active grid cell, or the bottom, right below it (row + 1)\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY) {\n        // This is an active shape cell. Check below it.\n        // Is this shape at the bottom?\n        if (row === grid.length - 1) {\n          console.log(\"canShapeMoveDown1Step: no! shape is at the bottom\");\n          // This shape CANNOT move down any more\n          return false;\n        } else if (grid[row + 1][col].status !== CellStatus.EMPTY) {\n          console.log(\"canShapeMoveDown1Step: no! there's another shape in the way\");\n          // The  grid has an active cell in the next row: shape CANNOT move down any more\n          return false;\n        }\n      }\n    }\n  }\n  // Did not find any grid cells that would block this shape from moving down\n  return true;\n}\n\nexport function canShapeMoveLeft(shape: GridState, grid: GridState): boolean {\n  // Check the first col of each row of the shape's grid to ensure nothing is in it\n  for (let row = 0; row < shape.length; row++) {\n    if (shape[row][0].status !== CellStatus.EMPTY) {\n      // There's part of the shape in the leftmost col! can't move left\n      return false;\n    }\n  }\n  // Need to also check that there is nothing in the grid to the left of the shape\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY) {\n        // Found an active shape cell, which we KNOW is not in the first column (due to the check above)\n        // Check col - 1 in the grid\n        if (grid[row][col - 1].status !== CellStatus.EMPTY) {\n          // There's already something to the immediate left of the shape! can't move left\n          return false;\n        }\n      }\n    }\n  }\n  // Otherwise: CAN move left\n  return true;\n}\n\nexport function moveShapeLeft(shape: GridState): GridState {\n  // Remove the first column, and add a column to the end\n  const movedGridState: GridState = [];\n  for (let row = 0; row < shape.length; row++) {\n    movedGridState[row] = [...shape[row]];\n    // Remove first item in the row (first column)\n    movedGridState[row].shift();\n    // Add empty cell to the end (last column)\n    movedGridState[row].push(getEmptyCell());\n  }\n  return movedGridState;\n}\n\nexport function canShapeMoveRight(shape: GridState, grid: GridState): boolean {\n  // Check the LAST col of each row of the shape's grid to ensure nothing is in it\n  for (let row = 0; row < shape.length; row++) {\n    const lastColIndex = shape[row].length - 1;\n    if (shape[row][lastColIndex].status !== CellStatus.EMPTY) {\n      // There's part of the shape in the rightmost col! can't move right\n      return false;\n    }\n  }\n  // Need to also check that there is nothing in the grid to the RIGHT of the shape\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY) {\n        // Found an active shape cell, which we KNOW is not in the last column (due to the check above)\n        // Check col + 1 in the grid\n        if (grid[row][col + 1].status !== CellStatus.EMPTY) {\n          // There's already something to the immediate RIGHT of the shape! can't move right\n          return false;\n        }\n      }\n    }\n  }\n  // Otherwise: CAN move right\n  return true;\n}\n\nexport function moveShapeRight(shape: GridState): GridState {\n  // Remove the last column, and add a column to the start\n  const movedGridState: GridState = [];\n  for (let row = 0; row < shape.length; row++) {\n    movedGridState[row] = [...shape[row]];\n    // Remove last item in the row (rightmost column)\n    movedGridState[row].pop();\n    // Add empty cell to the start (leftmost column)\n    movedGridState[row].unshift(getEmptyCell());\n  }\n  return movedGridState;\n}\n\nexport function doesShapeCollideWithAnother(shape: GridState, grid: GridState): boolean {\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY && grid[row][col].status !== CellStatus.EMPTY) {\n        // There's already a shape in this spot!\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function moveShapeDown(shape: GridState): GridState {\n  // Since the top-left of the Grid is 0,0, moving down can be done by adding a new row to the\n  // \"top\" and deleting the last row\n  const movedShape = [...shape];\n  // Remove last row\n  movedShape.pop();\n  const width = shape[0].length;\n  // Add empty row to beginning\n  movedShape.unshift(getEmptyRow(width));\n  return movedShape;\n}\n\n// 1000 for level 1, 722 for level 2, 560 for level 3, 445 for level 4 ...\nexport function getGameLoopSpeedForLevel(level: number): number {\n  // Speed maxed at 200ms between game loop iterations\n  return Math.max(Math.floor(1000 - 400 * Math.log(level)), 200);\n}\n","import React from \"react\";\n\ninterface Props {\n  level: number;\n  score: number;\n}\n\nexport function Score(props: Props) {\n  return (\n    <div className=\"Score\">\n      <div>Score: {props.score}</div>\n      <div>Level: {props.level}</div>\n    </div>\n  );\n}\n","import React from \"react\";\n\ninterface Props {\n  rotateShape(): void;\n  moveLeft(): void;\n  moveDown(): void;\n  moveRight(): void;\n}\n\nexport function Controls(props: Props) {\n  const { rotateShape, moveLeft, moveDown, moveRight } = props;\n\n  return (\n    <div className=\"Controls\">\n      {/* Controls for devices without keyboards */}\n      <div className=\"Controls-TopRow\">\n        <button onClick={() => rotateShape()}>\n          <span role=\"img\" aria-label=\"rotate arrow button (counter clockwise)\">\n            🔄\n          </span>\n        </button>\n      </div>\n      <div className=\"Controls-BottomRow\">\n        <button onClick={() => moveLeft()}>\n          <span role=\"img\" aria-label=\"left arrow button\">\n            ⬅️\n          </span>\n        </button>\n        <button onClick={() => moveDown()}>\n          <span role=\"img\" aria-label=\"down arrow button\">\n            ⬇️\n          </span>\n        </button>\n        <button onClick={() => moveRight()}>\n          <span role=\"img\" aria-label=\"right arrow button\">\n            ➡️\n          </span>\n        </button>\n      </div>\n    </div>\n  );\n}\n","import React, { useState, useEffect } from \"react\";\nimport \"./App.css\";\nimport { Shape } from \"./shapes/Shape\";\nimport { useKeyPress } from \"./hooks/useKeyPress\";\nimport { useInterval } from \"./hooks/useInterval\";\nimport {\n  GridCellState,\n  GridState,\n  initEmptyGrid,\n  getGridStateForShape,\n  mergeShapeIntoGrid,\n  Result,\n  areThereAnyCompleteRows,\n  removeCompleteRows,\n} from \"./model/Grid\";\nimport {\n  canShapeMoveDown1Step,\n  canShapeMoveLeft,\n  canShapeMoveRight,\n  doesShapeCollideWithAnother,\n  getGameLoopSpeedForLevel,\n} from \"./physics/Movement\";\nimport { Score } from \"./Score\";\nimport { Controls } from \"./Controls\";\n\ninterface Props {\n  height: number;\n  width: number;\n  shapes: Shape[];\n  level: number;\n  gameOver(): void;\n  levelComplete(): void;\n}\n\nexport function TetrisGrid(props: Props) {\n  const { width, height, shapes, level, gameOver, levelComplete } = props;\n\n  // Is the main game loop running?\n  const [isRunning, setIsRunning] = useState(true);\n\n  // Player's score. Updated when a complete row is removed.\n  const [score, setScore] = useState(0);\n\n  // The state of the Tetris grid (board). Initially empty\n  const [gridState, setGridState] = useState<GridState>(initEmptyGrid(width, height));\n\n  // Tracks the index of the current shape\n  const [shapeIndex, setShapeIndex] = useState(0);\n\n  // If a shape can be rotated into different positions, the position can be controlled by setting this index\n  // This value is controlled by the user\n  const [activeShapePositionIndex, setActiveShapePositionIndex] = useState(0);\n\n  // Track the active shape's position for when we need to rotate it\n  const [activeShapeRow, setActiveShapeRow] = useState(0);\n  const [activeShapeCol, setActiveShapeCol] = useState(Math.floor(width / 2 - 1));\n\n  // The active shape will be represented by it's own GridState\n  // Each shape will be merged with the above gridState to be rendered\n  const getShapeGridResult = getGridStateForShape(\n    shapes[shapeIndex],\n    activeShapePositionIndex,\n    activeShapeRow,\n    activeShapeCol,\n    width,\n    height\n  );\n  let activeShapeGridState: GridState = getShapeGridResult.gridState;\n  if (getShapeGridResult.kind === Result.FAILURE) {\n    console.log(\n      `Failed to get activeShapeGridState! shapeIndex: ${shapeIndex}, activeShapeRow: ${activeShapeRow} (total rows: ${height})`\n    );\n  }\n\n  function runGameStep(): void {\n    // Is the game over?\n    if (isGameOver()) {\n      console.log(\"Done! Game over.\");\n      setIsRunning(false);\n      gameOver();\n    }\n    // Does the currently active shape have room to move down 1 step?\n    else if (shapes.length === 0 || canShapeMoveDown1Step(activeShapeGridState, gridState) === false) {\n      // It can't move down then!\n      console.log(\"Active shape CAN'T move down 1 step!\");\n\n      // MERGE this shape with the gridState to make it part of the background\n      let updatedGridState = mergeShapeIntoGrid(activeShapeGridState, gridState);\n      // Are there any complete rows?\n      if (areThereAnyCompleteRows(updatedGridState)) {\n        // Remove the completed rows, and replace them with empty rows at the top of the grid\n        const rowRemovalResult = removeCompleteRows(updatedGridState);\n        updatedGridState = rowRemovalResult.grid;\n        // Update the player's score\n        setScore(score + rowRemovalResult.completeRowCount * 10);\n      }\n      setGridState(updatedGridState);\n\n      // Pick the next shape as \"active\", or finish the game\n      const nextShapeIndex = shapeIndex + 1;\n      setShapeIndex(nextShapeIndex);\n      if (nextShapeIndex < shapes.length) {\n        // There is still at least 1 more shape\n        // Reset the active shape's position state\n        setActiveShapeRow(0);\n        setActiveShapeCol(Math.floor(width / 2 - 1));\n        setActiveShapePositionIndex(0);\n      } else {\n        // This was the last shape.\n        // Stop the game loop: done!\n        console.log(\"Done! out of shapes.\");\n        setIsRunning(false);\n        levelComplete();\n      }\n      return;\n    } else {\n      // The shape is not blocked, not at the bottom, and CAN move down 1 step\n      // Move it down by 1, into a temp Shape\n      console.log(\"Moving active shape down.\");\n      setActiveShapeRow(activeShapeRow + 1);\n    }\n  }\n\n  ////////////////////////\n  // Main tetris game loop\n  ////////////////////////\n  useInterval(\n    function () {\n      if (shapes.length > 0) {\n        runGameStep();\n      }\n    },\n    isRunning ? getGameLoopSpeedForLevel(level) : null\n  ); // Run once a second when isRunning === true\n\n  useEffect(\n    function () {\n      // New shapes have arrived!\n      if (shapes.length > 0 && isRunning === false) {\n        if (level === 1) {\n          // Game has been restarted: clear the grid\n          setGridState(initEmptyGrid(width, height));\n          // Reset score\n          setScore(0);\n        }\n        setActiveShapeRow(0);\n        setActiveShapeCol(Math.floor(width / 2 - 1));\n        setActiveShapePositionIndex(0);\n        setShapeIndex(0);\n        setIsRunning(true);\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [shapes]\n  );\n\n  // Handle key presses\n  const arrowLeftKeyPressed = useKeyPress(\"ArrowLeft\");\n  const arrowRightKeyPressed = useKeyPress(\"ArrowRight\");\n  const arrowUpKeyPressed = useKeyPress(\"ArrowUp\");\n  const arrowDownKeyPressed = useKeyPress(\"ArrowDown\");\n\n  function moveLeft(): void {\n    // Move the current shape left by 1, if there's room for it to move there\n    console.log(\"MOVE LEFT!\");\n    if (canShapeMoveLeft(activeShapeGridState, gridState)) {\n      setActiveShapeCol(activeShapeCol - 1);\n    }\n  }\n\n  useEffect(\n    function () {\n      if (arrowLeftKeyPressed) {\n        moveLeft();\n      }\n    },\n    // With react-hooks/exhaustive-deps rule \"fixed\", pressing an arrow key results in the shape\n    // moving ALL THE WAY over to the right/left\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [arrowLeftKeyPressed]\n  );\n\n  function moveRight(): void {\n    // Move the current shape right by 1, if there's room for it to move there\n    console.log(\"MOVE RIGHT!\");\n    if (canShapeMoveRight(activeShapeGridState, gridState)) {\n      setActiveShapeCol(activeShapeCol + 1);\n    }\n  }\n\n  useEffect(\n    function () {\n      if (arrowRightKeyPressed) {\n        moveRight();\n      }\n    },\n    // With react-hooks/exhaustive-deps rule \"fixed\", pressing an arrow key results in the shape\n    // moving ALL THE WAY over to the right/left\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [arrowRightKeyPressed]\n  );\n\n  function rotateShape(): void {\n    // Move the current shape right by 1, if there's room for it to move there\n    console.log(\"Up key pressed - change shape position!\");\n    const newPositionIndex = activeShapePositionIndex + 1;\n    const proposedShapeGridResult = getGridStateForShape(\n      shapes[shapeIndex],\n      newPositionIndex, // Note: using the new index\n      activeShapeRow,\n      activeShapeCol,\n      width,\n      height\n    );\n    if (proposedShapeGridResult.kind === Result.SUCCESS) {\n      // Success means that the rotated shape does not extend past the edges of the grid.\n      // Next, check if it collides with any existing cells in the gridState\n      if (doesShapeCollideWithAnother(proposedShapeGridResult.gridState, gridState) === false) {\n        // The shape does not collide with an existing active cell in the grid: update position\n        console.log(\"Rotated shape does not collide with any existing active cells!\");\n        setActiveShapePositionIndex(newPositionIndex);\n      } else {\n        console.log(\"Can't rotate the shape in this direction: collision!\");\n      }\n    } else {\n      console.log(\"Can't rotate the shape in this direction: off grid!\");\n    }\n  }\n\n  useEffect(\n    function () {\n      if (arrowUpKeyPressed) {\n        rotateShape();\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [arrowUpKeyPressed]\n  );\n\n  function moveDown(): void {\n    // Move the current shape down by 1, if there's room for it to move\n    console.log(\"MOVE DOWN!\");\n    if (canShapeMoveDown1Step(activeShapeGridState, gridState)) {\n      setActiveShapeRow(activeShapeRow + 1);\n    }\n  }\n\n  useEffect(\n    function () {\n      if (arrowDownKeyPressed) {\n        moveDown();\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [arrowDownKeyPressed]\n  );\n\n  function isGameOver(): boolean {\n    // Is the active shape in it's initial position and already colliding with another shape?\n    if (activeShapeRow === 0 && doesShapeCollideWithAnother(activeShapeGridState, gridState)) {\n      return true;\n    }\n    return false;\n  }\n\n  // Put the current shape and the grid together\n  const mergedGridState = mergeShapeIntoGrid(activeShapeGridState, gridState);\n\n  // Output the TetrisGrid based on this mergedGridState\n  return (\n    <div className=\"Tetris\">\n      <div className=\"Grid\">\n        {/* Loop through each ROW of the grid matrix */}\n        {mergedGridState.map((row: Array<GridCellState>, rowIndex: number) => {\n          return (\n            <div key={`row${rowIndex}`} className=\"row\">\n              {/* Loop through each CELL in the current row */}\n              {row.map((cell: GridCellState, cellIndex: number) => {\n                return (\n                  <div\n                    key={`row${rowIndex}-cell${cellIndex}`}\n                    className=\"cell\"\n                    style={{ backgroundColor: cell.color || \"white\" }}\n                  ></div>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n      <Score level={level} score={score} />\n      <Controls rotateShape={rotateShape} moveLeft={moveLeft} moveDown={moveDown} moveRight={moveRight} />\n    </div>\n  );\n}\n","import { useEffect, useRef } from \"react\";\n\n// useInterval - from https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nexport function useInterval(callback: () => void, delay: number | null) {\n  const savedCallback = useRef<() => void>(() => void 0);\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n","import { Shape } from \"./Shape\";\nimport { square } from \"./Square\";\nimport { line } from \"./Line\";\nimport { hockeyStick } from \"./HockeyStick\";\nimport { sShape } from \"./sShape\";\nimport { jShape } from \"./jShape\";\nimport { zShape } from \"./zShape\";\nimport { tShape } from \"./tShape\";\n\nconst knownShapes = [\n  () => square(),\n  () => line(),\n  () => hockeyStick(),\n  () => sShape(),\n  () => jShape(),\n  () => zShape(),\n  () => tShape(),\n];\n\nfunction getRandomShapeIndex(): number {\n  // Find a number between 0 and the length of knownShapes\n  return Math.floor(Math.random() * knownShapes.length);\n}\n\nconst colors = [\"blue\", \"green\", \"orange\", \"red\", \"pink\", \"lightgray\"];\n\nfunction getRandomColorIndex(): number {\n  // Find a number between 0 and the length of colors\n  return Math.floor(Math.random() * colors.length);\n}\n\n// Get a number of random shapes (count) each with a random color\nexport function getRandomShapes(count: number): Shape[] {\n  const shapes: Shape[] = [];\n  for (let i = 0; i < count; i++) {\n    const randomShape: Shape = knownShapes[getRandomShapeIndex()]();\n    const randomColor: string = colors[getRandomColorIndex()];\n    randomShape.color = randomColor;\n    shapes.push(randomShape);\n  }\n  return shapes;\n}\n\nexport function getNumberOfShapesForLevel(level: number): number {\n  // 30 for level 1, 50 for level 2, 62 level 3, and so on\n  return Math.floor(30 * (Math.log(level) + 1));\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function square(): Shape {\n  const squareMatrix: ShapeMatrix = [\n    [1, 1],\n    [1, 1],\n  ];\n  return {\n    name: \"square\",\n    color: \"red\",\n    positions: [squareMatrix], // A square rotated is the same thing\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function line(): Shape {\n  // prettier-ignore\n  const verticalLine: ShapeMatrix = [\n    [1],\n    [1],\n    [1],\n    [1]\n  ];\n  const horizontalLine: ShapeMatrix = [[1, 1, 1, 1]];\n  return {\n    name: \"line\",\n    color: \"blue\",\n    positions: [verticalLine, horizontalLine], // A square rotated is the same thing\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function hockeyStick(): Shape {\n  // prettier-ignore\n  const hockeyStickFlat: ShapeMatrix = [\n    [0, 0,  1],\n    [1, 1,  1]\n  ];\n  const hockeyStickUp: ShapeMatrix = [\n    [1, 1],\n    [0, 1],\n    [0, 1],\n  ];\n  const hockeyStickOver: ShapeMatrix = [\n    [1, 1, 1],\n    [1, 0, 0],\n  ];\n  const hockeyStickDown: ShapeMatrix = [\n    [1, 0],\n    [1, 0],\n    [1, 1],\n  ];\n  return {\n    name: \"hockeyStick\",\n    positions: [hockeyStickFlat, hockeyStickUp, hockeyStickOver, hockeyStickDown],\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function sShape(): Shape {\n  const zigZagSide: ShapeMatrix = [\n    [0, 1, 1],\n    [1, 1, 0],\n  ];\n  const zigZagUp: ShapeMatrix = [\n    [1, 0],\n    [1, 1],\n    [0, 1],\n  ];\n  return {\n    name: \"sShape\",\n    positions: [zigZagSide, zigZagUp],\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function jShape(): Shape {\n  const hockeyStickFlat: ShapeMatrix = [\n    [1, 1, 1],\n    [0, 0, 1],\n  ];\n  const hockeyStickUp: ShapeMatrix = [\n    [1, 1],\n    [1, 0],\n    [1, 0],\n  ];\n  const hockeyStickOver: ShapeMatrix = [\n    [1, 0, 0],\n    [1, 1, 1],\n  ];\n  const hockeyStickDown: ShapeMatrix = [\n    [0, 1],\n    [0, 1],\n    [1, 1],\n  ];\n  return {\n    name: \"jShape\",\n    positions: [hockeyStickFlat, hockeyStickUp, hockeyStickOver, hockeyStickDown],\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function zShape(): Shape {\n  // prettier-ignore\n  const zigZagSide: ShapeMatrix = [\n    [1, 1, 0],\n    [0, 1, 1],\n  ];\n  const zigZagUp: ShapeMatrix = [\n    [0, 1],\n    [1, 1],\n    [1, 0],\n  ];\n  return {\n    name: \"zShape\",\n    positions: [zigZagSide, zigZagUp],\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function tShape(): Shape {\n  const tUpsideDown: ShapeMatrix = [\n    [0, 1, 0],\n    [1, 1, 1],\n  ];\n  const tSideLeft: ShapeMatrix = [\n    [0, 1],\n    [1, 1],\n    [0, 1],\n  ];\n  const tRightSideUp: ShapeMatrix = [\n    [1, 1, 1],\n    [0, 1, 0],\n  ];\n  const tSideRight: ShapeMatrix = [\n    [1, 0],\n    [1, 1],\n    [1, 0],\n  ];\n  return {\n    name: \"tShape\",\n    positions: [tUpsideDown, tSideLeft, tRightSideUp, tSideRight],\n  };\n}\n","import React from \"react\";\n\nexport function Footer() {\n  return (\n    <footer>\n      <a href=\"https://github.com/blefebvre/react-tetris\" target=\"_blank\">\n        react-tetris\n      </a>{\" \"}\n      was made by{\" \"}\n      <a href=\"https://twitter.com/brucelefebvre\" target=\"_blank\">\n        @brucelefebvre\n      </a>\n    </footer>\n  );\n}\n","import React from \"react\";\n\ninterface Props {\n  active: boolean;\n}\n\nexport const Overlay: React.FunctionComponent<Props> = function (props) {\n  return (\n    <div id=\"overlay\" style={{ display: props.active ? \"flex\" : \"none\" }}>\n      <div className=\"message\">{props.children}</div>\n    </div>\n  );\n};\n","import React, { useState } from \"react\";\nimport \"./App.css\";\nimport { TetrisGrid } from \"./TetrisGrid\";\nimport { getRandomShapes, getNumberOfShapesForLevel } from \"./shapes/Generator\";\nimport { Footer } from \"./Footer\";\nimport { Overlay } from \"./Overlay\";\nimport { Shape } from \"./shapes/Shape\";\n\nexport function App() {\n  // Start at level 1\n  const [level, setLevel] = useState(1);\n  // The shapes, ordered by how they will appear. This is empty until \"Go\" is clicked\n  const [shapes, setShapes] = useState<Shape[]>([]);\n  // Overlay which shows the current level and \"Go\" button\n  const [showOverlay, setShowOverlay] = useState(true);\n  // Overlay which shows \"Game over\"\n  const [showGameOver, setShowGameOver] = useState(false);\n\n  function goClicked() {\n    setShowOverlay(false);\n    setShapes(getRandomShapes(getNumberOfShapesForLevel(level)));\n    //setShapes(getRandomShapes(4));\n    //setShapes([line(), line(), square()]);\n  }\n\n  function gameOver() {\n    setShowGameOver(true);\n  }\n\n  function levelComplete() {\n    const nextLevel = level + 1;\n    setShowOverlay(true);\n    setLevel(nextLevel);\n  }\n\n  function reset() {\n    setShowGameOver(false);\n    setLevel(1);\n    setShapes(getRandomShapes(getNumberOfShapesForLevel(1)));\n  }\n\n  return (\n    <div className=\"App\">\n      <TetrisGrid\n        level={level}\n        width={10}\n        height={15}\n        shapes={shapes}\n        gameOver={gameOver}\n        levelComplete={levelComplete}\n      />\n      <Overlay active={showOverlay}>\n        Level {level}. Ready? <br /> <button onClick={goClicked}>Go!</button>\n      </Overlay>\n      <Overlay active={showGameOver}>\n        Game over{\" \"}\n        <span role=\"img\" aria-label=\"confounded face\">\n          😖\n        </span>{\" \"}\n        <br /> <button onClick={reset}>Play again?</button>\n      </Overlay>\n      <Footer />\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { App } from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}