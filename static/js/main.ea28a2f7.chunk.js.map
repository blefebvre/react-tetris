{"version":3,"sources":["hooks/useKeyPress.ts","model/Grid.ts","physics/Movement.ts","Score.tsx","Controls.tsx","TetrisGrid.tsx","hooks/useInterval.ts","shapes/Generator.ts","shapes/Square.ts","shapes/Line.ts","shapes/HockeyStick.ts","shapes/sShape.ts","shapes/jShape.ts","shapes/zShape.ts","shapes/tShape.ts","Footer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["useKeyPress","targetKey","useState","keyPressed","setKeyPressed","useEffect","downHandler","key","upHandler","window","addEventListener","removeEventListener","CellStatus","Result","initEmptyGrid","width","height","grid","row","getEmptyRow","col","getEmptyCell","color","status","EMPTY","getGridStateForShape","shape","positionIndex","shapeRow","shapeCol","gridWidth","gridHeight","newShapeGrid","shapePosition","positions","length","currentCellRowIndex","currentCellColIndex","kind","FAILURE","gridState","FULL","SUCCESS","mergeShapeIntoGrid","mergedGridState","isRowComplete","canShapeMoveDown1Step","console","log","Score","props","className","score","level","Controls","rotateShape","moveLeft","moveDown","moveRight","onClick","role","aria-label","TetrisGrid","shapes","isRunning","setIsRunning","setScore","setGridState","shapeIndex","setShapeIndex","activeShapePositionIndex","setActiveShapePositionIndex","activeShapeRow","setActiveShapeRow","Math","floor","activeShapeCol","setActiveShapeCol","getShapeGridResult","activeShapeGridState","runGameStep","updatedGridState","areThereAnyCompleteRows","rowRemovalResult","gridWithCompleteRowsReplaced","completeRowCount","unshift","push","removeCompleteRows","nextShapeIndex","error","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","arrowLeftKeyPressed","arrowRightKeyPressed","arrowUpKeyPressed","arrowDownKeyPressed","canShapeMoveLeft","lastColIndex","canShapeMoveRight","newPositionIndex","proposedShapeGridResult","doesShapeCollideWithAnother","map","rowIndex","cell","cellIndex","style","backgroundColor","knownShapes","name","colors","getRandomShapes","count","i","randomShape","random","randomColor","Footer","href","target","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.ea28a2f7.chunk.js","sourcesContent":["import { useEffect, useState } from \"react\";\n\n// useKeyPress - from https://usehooks.com/useKeyPress/\nexport function useKeyPress(targetKey: string) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  // Add event listeners\n  useEffect(() => {\n    // If pressed key is our target key then set to true\n    function downHandler({ key }: KeyboardEvent) {\n      if (key === targetKey) {\n        setKeyPressed(true);\n      }\n    }\n\n    // If released key is our target key then set to false\n    const upHandler = ({ key }: KeyboardEvent) => {\n      if (key === targetKey) {\n        setKeyPressed(false);\n      }\n    };\n\n    window.addEventListener(\"keydown\", downHandler);\n    window.addEventListener(\"keyup\", upHandler);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener(\"keydown\", downHandler);\n      window.removeEventListener(\"keyup\", upHandler);\n    };\n  }, [targetKey]); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n}\n","import { Shape, ShapeMatrix } from \"../shapes/Shape\";\n\n// Grid related model types\n\nexport enum CellStatus {\n  EMPTY,\n  FULL,\n}\n\nexport interface GridCellState {\n  color: string;\n  status: CellStatus;\n}\n\n// The entire grid: a 2d array\nexport type GridState = GridCellState[][];\n\nexport enum Result {\n  SUCCESS,\n  FAILURE,\n}\n\nexport interface NewGridStateResult {\n  kind: Result;\n  gridState: GridState;\n}\n\n// Return 2d array of GridCellState items\nexport function initEmptyGrid(width: number, height: number): GridState {\n  const grid: Array<Array<GridCellState>> = [];\n  for (let row = 0; row < height; row++) {\n    grid[row] = getEmptyRow(width);\n  }\n  return grid;\n}\n\nexport function getEmptyRow(width: number): GridCellState[] {\n  const row = [];\n  for (let col = 0; col < width; col++) {\n    row[col] = getEmptyCell();\n  }\n  return row;\n}\n\nexport function getEmptyCell(): GridCellState {\n  return {\n    color: \"white\",\n    status: CellStatus.EMPTY,\n  };\n}\n\nexport function getGridStateForShape(\n  shape: Shape,\n  positionIndex: number,\n  shapeRow: number,\n  shapeCol: number,\n  gridWidth: number,\n  gridHeight: number\n): NewGridStateResult {\n  const newShapeGrid = initEmptyGrid(gridWidth, gridHeight);\n\n  // Choose the shape's position (this is how rotation is implemented)\n  const shapePosition: ShapeMatrix = shape.positions[positionIndex % shape.positions.length];\n\n  // Assumes grid will always be big enough for the shape!\n  // shapePosition.length is the HEIGHT of the new shape\n  for (let row = 0; row < shapePosition.length; row++) {\n    for (let col = 0; col < shapePosition[row].length; col++) {\n      const currentCellFlag = shapePosition[row][col];\n      if (currentCellFlag === 1) {\n        // Set the grid cell to ON!\n        const currentCellRowIndex = row + shapeRow;\n        const currentCellColIndex = col + shapeCol;\n        // It's possible that - due to rotation - a cell could be attempted to be set which is\n        // \"out of bounds\" of the grid. Return a failure in this case\n        if (currentCellRowIndex >= newShapeGrid.length || currentCellColIndex >= newShapeGrid[row].length) {\n          return {\n            kind: Result.FAILURE,\n            gridState: newShapeGrid,\n          };\n        }\n        newShapeGrid[currentCellRowIndex][currentCellColIndex] = {\n          color: shape.color || \"1\",\n          status: CellStatus.FULL,\n        };\n      }\n    }\n  }\n  return {\n    kind: Result.SUCCESS,\n    gridState: newShapeGrid,\n  };\n}\n\nexport function mergeShapeIntoGrid(shape: GridState, grid: GridState): GridState {\n  const mergedGridState: GridState = [];\n  for (let row = 0; row < shape.length; row++) {\n    // Copy the current row to the merged grid\n    mergedGridState[row] = [...grid[row]];\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY) {\n        mergedGridState[row][col] = { ...shape[row][col] };\n      }\n    }\n  }\n  return mergedGridState;\n}\n\nfunction isRowComplete(row: GridCellState[]): boolean {\n  for (let col = 0; col < row.length; col++) {\n    if (row[col].status === CellStatus.EMPTY) {\n      // Short-circuit as soon as we find a single empty cell\n      return false;\n    }\n  }\n  // Made it through the entire row without finding an empty cell, so this row is complete!\n  return true;\n}\n\nexport function areThereAnyCompleteRows(grid: GridState): boolean {\n  // Search up from the bottom, which is where the complete rows are likely to be found\n  for (let row = grid.length - 1; row >= 0; row--) {\n    if (isRowComplete(grid[row])) {\n      // Complete row found!\n      return true;\n    }\n  }\n  // Did not find any complete rows\n  return false;\n}\n\ninterface RowRemovalResult {\n  grid: GridState;\n  completeRowCount: number;\n}\n\nexport function removeCompleteRows(grid: GridState): RowRemovalResult {\n  const gridWithCompleteRowsReplaced = [];\n  let completeRowCount = 0;\n  for (let row = 0; row < grid.length; row++) {\n    if (isRowComplete(grid[row])) {\n      // Complete row found!\n      // Unshift an empty row instead of the current grid row\n      completeRowCount++;\n      gridWithCompleteRowsReplaced.unshift(getEmptyRow(grid[row].length));\n    } else {\n      // This row is not complete: add it as-is to the end of gridWithCompleteRowsReplaced\n      gridWithCompleteRowsReplaced.push([...grid[row]]);\n    }\n  }\n  return {\n    completeRowCount,\n    grid: gridWithCompleteRowsReplaced,\n  };\n}\n","import { GridState, CellStatus, getEmptyRow, getEmptyCell } from \"../model/Grid\";\n\n// Can this shape move down 1 step? Or, has it reached the bottom of the grid, or another shape?\nexport function canShapeMoveDown1Step(shape: GridState, grid: GridState): boolean {\n  // Find each active cell of the shape. Check for an active grid cell, or the bottom, right below it (row + 1)\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY) {\n        // This is an active shape cell. Check below it.\n        // Is this shape at the bottom?\n        if (row === grid.length - 1) {\n          console.log(\"canShapeMoveDown1Step: no! shape is at the bottom\");\n          // This shape CANNOT move down any more\n          return false;\n        } else if (grid[row + 1][col].status !== CellStatus.EMPTY) {\n          console.log(\"canShapeMoveDown1Step: no! there's another shape in the way\");\n          // The  grid has an active cell in the next row: shape CANNOT move down any more\n          return false;\n        }\n      }\n    }\n  }\n  // Did not find any grid cells that would block this shape from moving down\n  return true;\n}\n\nexport function canShapeMoveLeft(shape: GridState, grid: GridState): boolean {\n  // Check the first col of each row of the shape's grid to ensure nothing is in it\n  for (let row = 0; row < shape.length; row++) {\n    if (shape[row][0].status !== CellStatus.EMPTY) {\n      // There's part of the shape in the leftmost col! can't move left\n      return false;\n    }\n  }\n  // Need to also check that there is nothing in the grid to the left of the shape\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY) {\n        // Found an active shape cell, which we KNOW is not in the first column (due to the check above)\n        // Check col - 1 in the grid\n        if (grid[row][col - 1].status !== CellStatus.EMPTY) {\n          // There's already something to the immediate left of the shape! can't move left\n          return false;\n        }\n      }\n    }\n  }\n  // Otherwise: CAN move left\n  return true;\n}\n\nexport function moveShapeLeft(shape: GridState): GridState {\n  // Remove the first column, and add a column to the end\n  const movedGridState: GridState = [];\n  for (let row = 0; row < shape.length; row++) {\n    movedGridState[row] = [...shape[row]];\n    // Remove first item in the row (first column)\n    movedGridState[row].shift();\n    // Add empty cell to the end (last column)\n    movedGridState[row].push(getEmptyCell());\n  }\n  return movedGridState;\n}\n\nexport function canShapeMoveRight(shape: GridState, grid: GridState): boolean {\n  // Check the LAST col of each row of the shape's grid to ensure nothing is in it\n  for (let row = 0; row < shape.length; row++) {\n    const lastColIndex = shape[row].length - 1;\n    if (shape[row][lastColIndex].status !== CellStatus.EMPTY) {\n      // There's part of the shape in the rightmost col! can't move right\n      return false;\n    }\n  }\n  // Need to also check that there is nothing in the grid to the RIGHT of the shape\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY) {\n        // Found an active shape cell, which we KNOW is not in the last column (due to the check above)\n        // Check col + 1 in the grid\n        if (grid[row][col + 1].status !== CellStatus.EMPTY) {\n          // There's already something to the immediate RIGHT of the shape! can't move right\n          return false;\n        }\n      }\n    }\n  }\n  // Otherwise: CAN move right\n  return true;\n}\n\nexport function moveShapeRight(shape: GridState): GridState {\n  // Remove the last column, and add a column to the start\n  const movedGridState: GridState = [];\n  for (let row = 0; row < shape.length; row++) {\n    movedGridState[row] = [...shape[row]];\n    // Remove last item in the row (rightmost column)\n    movedGridState[row].pop();\n    // Add empty cell to the start (leftmost column)\n    movedGridState[row].unshift(getEmptyCell());\n  }\n  return movedGridState;\n}\n\nexport function doesShapeCollideWithAnother(shape: GridState, grid: GridState): boolean {\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col].status !== CellStatus.EMPTY && grid[row][col].status !== CellStatus.EMPTY) {\n        // There's already a shape in this spot!\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function moveShapeDown(shape: GridState): GridState {\n  // Since the top-left of the Grid is 0,0, moving down can be done by adding a new row to the\n  // \"top\" and deleting the last row\n  const movedShape = [...shape];\n  // Remove last row\n  movedShape.pop();\n  const width = shape[0].length;\n  // Add empty row to beginning\n  movedShape.unshift(getEmptyRow(width));\n  return movedShape;\n}\n","import React from \"react\";\n\ninterface Props {\n  level: number;\n  score: number;\n}\n\nexport function Score(props: Props) {\n  return (\n    <div className=\"Score\">\n      <div>Score: {props.score}</div>\n      <div>Level: {props.level}</div>\n    </div>\n  );\n}\n","import React from \"react\";\n\ninterface Props {\n  rotateShape(): void;\n  moveLeft(): void;\n  moveDown(): void;\n  moveRight(): void;\n}\n\nexport function Controls(props: Props) {\n  const { rotateShape, moveLeft, moveDown, moveRight } = props;\n\n  return (\n    <div className=\"Controls\">\n      {/* Controls for devices without keyboards */}\n      <div className=\"Controls-TopRow\">\n        <button onClick={() => rotateShape()}>\n          <span role=\"img\" aria-label=\"rotate arrow button (counter clockwise)\">\n            🔄\n          </span>\n        </button>\n      </div>\n      <div className=\"Controls-BottomRow\">\n        <button onClick={() => moveLeft()}>\n          <span role=\"img\" aria-label=\"left arrow button\">\n            ⏪\n          </span>\n        </button>\n        <button onClick={() => moveDown()}>\n          <span role=\"img\" aria-label=\"down arrow button\">\n            ⏬\n          </span>\n        </button>\n        <button onClick={() => moveRight()}>\n          <span role=\"img\" aria-label=\"right arrow button\">\n            ⏩\n          </span>\n        </button>\n      </div>\n    </div>\n  );\n}\n","import React, { useState, useEffect } from \"react\";\nimport \"./App.css\";\nimport { Shape } from \"./shapes/Shape\";\nimport { useKeyPress } from \"./hooks/useKeyPress\";\nimport { useInterval } from \"./hooks/useInterval\";\nimport {\n  GridCellState,\n  GridState,\n  initEmptyGrid,\n  getGridStateForShape,\n  mergeShapeIntoGrid,\n  Result,\n  areThereAnyCompleteRows,\n  removeCompleteRows,\n} from \"./model/Grid\";\nimport {\n  canShapeMoveDown1Step,\n  canShapeMoveLeft,\n  canShapeMoveRight,\n  doesShapeCollideWithAnother,\n} from \"./physics/Movement\";\nimport { Score } from \"./Score\";\nimport { Controls } from \"./Controls\";\n\ninterface Props {\n  height: number;\n  width: number;\n  shapes: Shape[];\n  level: number;\n}\n\nexport function TetrisGrid(props: Props) {\n  const { width, height, shapes, level } = props;\n\n  // Is the main game loop running?\n  const [isRunning, setIsRunning] = useState(true);\n\n  // Player's score. Updated when a complete row is removed.\n  const [score, setScore] = useState(0);\n\n  // The state of the Tetris grid (board). Initially empty\n  const [gridState, setGridState] = useState<GridState>(initEmptyGrid(width, height));\n\n  // Tracks the index of the current shape\n  const [shapeIndex, setShapeIndex] = useState(0);\n\n  // If a shape can be rotated into different positions, the position can be controlled by setting this index\n  // This value is controlled by the user\n  const [activeShapePositionIndex, setActiveShapePositionIndex] = useState(0);\n\n  // Track the active shape's position for when we need to rotate it\n  const [activeShapeRow, setActiveShapeRow] = useState(0);\n  const [activeShapeCol, setActiveShapeCol] = useState(Math.floor(width / 2 - 1));\n\n  // The active shape will be represented by it's own GridState\n  // Each shape will be merged with the above gridState to be rendered\n  const getShapeGridResult = getGridStateForShape(\n    shapes[shapeIndex],\n    activeShapePositionIndex,\n    activeShapeRow,\n    activeShapeCol,\n    width,\n    height\n  );\n  let activeShapeGridState: GridState = getShapeGridResult.gridState;\n  if (getShapeGridResult.kind === Result.FAILURE) {\n    console.error(\"Result.FAILURE detected! TODO: handle it!!\");\n  }\n\n  function runGameStep(): void {\n    // Does the currently active shape have room to move down 1 step?\n    if (canShapeMoveDown1Step(activeShapeGridState, gridState) === false) {\n      // It can't move down then!\n      console.log(\"Active shape CAN'T move down 1 step!\");\n\n      // MERGE this shape with the gridState to make it part of the background\n      let updatedGridState = mergeShapeIntoGrid(activeShapeGridState, gridState);\n      // Are there any complete rows?\n      if (areThereAnyCompleteRows(updatedGridState)) {\n        // Remove the completed rows, and replace them with empty rows at the top of the grid\n        const rowRemovalResult = removeCompleteRows(updatedGridState);\n        updatedGridState = rowRemovalResult.grid;\n        // Update the player's score\n        setScore(score + rowRemovalResult.completeRowCount * 10);\n      }\n      setGridState(updatedGridState);\n\n      // Pick the next shape as \"active\", or finish the game\n      const nextShapeIndex = shapeIndex + 1;\n      if (nextShapeIndex < shapes.length) {\n        setShapeIndex(nextShapeIndex);\n        // Reset the active shape's position state\n        setActiveShapeRow(0);\n        setActiveShapeCol(Math.floor(width / 2 - 1));\n        setActiveShapePositionIndex(0);\n      } else {\n        // Stop the game loop: done!\n        console.log(\"Done! out of shapes.\");\n        setIsRunning(false);\n      }\n      return;\n    } else {\n      // The shape is not blocked, not at the bottom, and CAN move down 1 step\n      // Move it down by 1, into a temp Shape\n      console.log(\"Moving active shape down.\");\n      setActiveShapeRow(activeShapeRow + 1);\n    }\n  }\n\n  ////////////////////////\n  // Main tetris game loop\n  ////////////////////////\n  useInterval(\n    function () {\n      runGameStep();\n    },\n    isRunning ? 1000 : null\n  ); // Run once a second when isRunning === true\n\n  // Handle key presses\n  const arrowLeftKeyPressed = useKeyPress(\"ArrowLeft\");\n  const arrowRightKeyPressed = useKeyPress(\"ArrowRight\");\n  const arrowUpKeyPressed = useKeyPress(\"ArrowUp\");\n  const arrowDownKeyPressed = useKeyPress(\"ArrowDown\");\n\n  function moveLeft(): void {\n    // Move the current shape left by 1, if there's room for it to move there\n    console.log(\"MOVE LEFT!\");\n    if (canShapeMoveLeft(activeShapeGridState, gridState)) {\n      setActiveShapeCol(activeShapeCol - 1);\n    }\n  }\n\n  useEffect(\n    function () {\n      if (arrowLeftKeyPressed) {\n        moveLeft();\n      }\n    },\n    // With react-hooks/exhaustive-deps rule \"fixed\", pressing an arrow key results in the shape\n    // moving ALL THE WAY over to the right/left\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [arrowLeftKeyPressed]\n  );\n\n  function moveRight(): void {\n    // Move the current shape right by 1, if there's room for it to move there\n    console.log(\"MOVE RIGHT!\");\n    if (canShapeMoveRight(activeShapeGridState, gridState)) {\n      setActiveShapeCol(activeShapeCol + 1);\n    }\n  }\n\n  useEffect(\n    function () {\n      if (arrowRightKeyPressed) {\n        moveRight();\n      }\n    },\n    // With react-hooks/exhaustive-deps rule \"fixed\", pressing an arrow key results in the shape\n    // moving ALL THE WAY over to the right/left\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [arrowRightKeyPressed]\n  );\n\n  function rotateShape(): void {\n    // Move the current shape right by 1, if there's room for it to move there\n    console.log(\"Up key pressed - change shape position!\");\n    const newPositionIndex = activeShapePositionIndex + 1;\n    const proposedShapeGridResult = getGridStateForShape(\n      shapes[shapeIndex],\n      newPositionIndex, // Note: using the new index\n      activeShapeRow,\n      activeShapeCol,\n      width,\n      height\n    );\n    if (proposedShapeGridResult.kind === Result.SUCCESS) {\n      // Success means that the rotated shape does not extend past the edges of the grid.\n      // Next, check if it collides with any existing cells in the gridState\n      if (doesShapeCollideWithAnother(proposedShapeGridResult.gridState, gridState) === false) {\n        // The shape does not collide with an existing active cell in the grid: update position\n        console.log(\"Rotated shape does not collide with any existing active cells!\");\n        setActiveShapePositionIndex(newPositionIndex);\n      } else {\n        console.log(\"Can't rotate the shape in this direction: collision!\");\n      }\n    } else {\n      console.log(\"Can't rotate the shape in this direction: off grid!\");\n    }\n  }\n\n  useEffect(\n    function () {\n      if (arrowUpKeyPressed) {\n        rotateShape();\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [arrowUpKeyPressed]\n  );\n\n  function moveDown(): void {\n    // Move the current shape down by 1, if there's room for it to move\n    console.log(\"MOVE DOWN!\");\n    if (canShapeMoveDown1Step(activeShapeGridState, gridState)) {\n      setActiveShapeRow(activeShapeRow + 1);\n    }\n  }\n\n  useEffect(\n    function () {\n      if (arrowDownKeyPressed) {\n        moveDown();\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [arrowDownKeyPressed]\n  );\n\n  // Put the current shape and the grid together\n  const mergedGridState = mergeShapeIntoGrid(activeShapeGridState, gridState);\n\n  // Output the TetrisGrid based on this mergedGridState\n  return (\n    <div className=\"Tetris\">\n      <div className=\"Grid\">\n        {/* Loop through each ROW of the grid matrix */}\n        {mergedGridState.map((row: Array<GridCellState>, rowIndex: number) => {\n          return (\n            <div key={`row${rowIndex}`} className=\"row\">\n              {/* Loop through each CELL in the current row */}\n              {row.map((cell: GridCellState, cellIndex: number) => {\n                return (\n                  <div\n                    key={`row${rowIndex}-cell${cellIndex}`}\n                    className=\"cell\"\n                    style={{ backgroundColor: cell.color || \"white\" }}\n                  ></div>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n      <Score level={level} score={score} />\n      <Controls rotateShape={rotateShape} moveLeft={moveLeft} moveDown={moveDown} moveRight={moveRight} />\n    </div>\n  );\n}\n","import { useEffect, useRef } from \"react\";\n\n// useInterval - from https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nexport function useInterval(callback: () => void, delay: number | null) {\n  const savedCallback = useRef<() => void>(() => void 0);\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n","import { Shape } from \"./Shape\";\nimport { square } from \"./Square\";\nimport { line } from \"./Line\";\nimport { hockeyStick } from \"./HockeyStick\";\nimport { sShape } from \"./sShape\";\nimport { jShape } from \"./jShape\";\nimport { zShape } from \"./zShape\";\nimport { tShape } from \"./tShape\";\n\nconst knownShapes = [\n  () => square(),\n  () => line(),\n  () => hockeyStick(),\n  () => sShape(),\n  () => jShape(),\n  () => zShape(),\n  () => tShape(),\n];\n\nfunction getRandomShapeIndex(): number {\n  // Find a number between 0 and the length of knownShapes\n  return Math.floor(Math.random() * knownShapes.length);\n}\n\nconst colors = [\"blue\", \"green\", \"orange\", \"red\", \"pink\", \"lightgray\"];\n\nfunction getRandomColorIndex(): number {\n  // Find a number between 0 and the length of colors\n  return Math.floor(Math.random() * colors.length);\n}\n\n// Get a number of random shapes (count) each with a random color\nexport function getRandomShapes(count: number): Shape[] {\n  const shapes: Shape[] = [];\n  for (let i = 0; i < count; i++) {\n    const randomShape: Shape = knownShapes[getRandomShapeIndex()]();\n    const randomColor: string = colors[getRandomColorIndex()];\n    randomShape.color = randomColor;\n    shapes.push(randomShape);\n  }\n  return shapes;\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function square(): Shape {\n  const squareMatrix: ShapeMatrix = [\n    [1, 1],\n    [1, 1],\n  ];\n  return {\n    name: \"square\",\n    color: \"red\",\n    positions: [squareMatrix], // A square rotated is the same thing\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function line(): Shape {\n  // prettier-ignore\n  const verticalLine: ShapeMatrix = [\n    [1],\n    [1],\n    [1],\n    [1]\n  ];\n  const horizontalLine: ShapeMatrix = [[1, 1, 1, 1]];\n  return {\n    name: \"line\",\n    color: \"blue\",\n    positions: [verticalLine, horizontalLine], // A square rotated is the same thing\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function hockeyStick(): Shape {\n  // prettier-ignore\n  const hockeyStickFlat: ShapeMatrix = [\n    [0, 0,  1],\n    [1, 1,  1]\n  ];\n  const hockeyStickUp: ShapeMatrix = [\n    [1, 1],\n    [0, 1],\n    [0, 1],\n  ];\n  const hockeyStickOver: ShapeMatrix = [\n    [1, 1, 1],\n    [1, 0, 0],\n  ];\n  const hockeyStickDown: ShapeMatrix = [\n    [1, 0],\n    [1, 0],\n    [1, 1],\n  ];\n  return {\n    name: \"hockeyStick\",\n    positions: [hockeyStickFlat, hockeyStickUp, hockeyStickOver, hockeyStickDown],\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function sShape(): Shape {\n  const zigZagSide: ShapeMatrix = [\n    [0, 1, 1],\n    [1, 1, 0],\n  ];\n  const zigZagUp: ShapeMatrix = [\n    [1, 0],\n    [1, 1],\n    [0, 1],\n  ];\n  return {\n    name: \"sShape\",\n    positions: [zigZagSide, zigZagUp],\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function jShape(): Shape {\n  const hockeyStickFlat: ShapeMatrix = [\n    [1, 1, 1],\n    [0, 0, 1],\n  ];\n  const hockeyStickUp: ShapeMatrix = [\n    [1, 1],\n    [1, 0],\n    [1, 0],\n  ];\n  const hockeyStickOver: ShapeMatrix = [\n    [1, 0, 0],\n    [1, 1, 1],\n  ];\n  const hockeyStickDown: ShapeMatrix = [\n    [0, 1],\n    [0, 1],\n    [1, 1],\n  ];\n  return {\n    name: \"jShape\",\n    positions: [hockeyStickFlat, hockeyStickUp, hockeyStickOver, hockeyStickDown],\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function zShape(): Shape {\n  // prettier-ignore\n  const zigZagSide: ShapeMatrix = [\n    [1, 1, 0],\n    [0, 1, 1],\n  ];\n  const zigZagUp: ShapeMatrix = [\n    [0, 1],\n    [1, 1],\n    [1, 0],\n  ];\n  return {\n    name: \"zShape\",\n    positions: [zigZagSide, zigZagUp],\n  };\n}\n","import { Shape, ShapeMatrix } from \"./Shape\";\n\nexport function tShape(): Shape {\n  const tUpsideDown: ShapeMatrix = [\n    [0, 1, 0],\n    [1, 1, 1],\n  ];\n  const tSideLeft: ShapeMatrix = [\n    [0, 1],\n    [1, 1],\n    [0, 1],\n  ];\n  const tRightSideUp: ShapeMatrix = [\n    [1, 1, 1],\n    [0, 1, 0],\n  ];\n  const tSideRight: ShapeMatrix = [\n    [1, 0],\n    [1, 1],\n    [1, 0],\n  ];\n  return {\n    name: \"tShape\",\n    positions: [tUpsideDown, tSideLeft, tRightSideUp, tSideRight],\n  };\n}\n","import React from \"react\";\n\nexport function Footer() {\n  return (\n    <footer>\n      <a href=\"https://github.com/blefebvre/react-tetris\" target=\"_blank\">\n        react-tetris\n      </a>{\" \"}\n      was made by{\" \"}\n      <a href=\"https://twitter.com/brucelefebvre\" target=\"_blank\">\n        @brucelefebvre\n      </a>\n    </footer>\n  );\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport { TetrisGrid } from \"./TetrisGrid\";\nimport { getRandomShapes } from \"./shapes/Generator\";\nimport { Footer } from \"./Footer\";\nimport { line } from \"./shapes/Line\";\nimport { square } from \"./shapes/Square\";\n\nexport function App() {\n  return (\n    <div className=\"App\">\n      <TetrisGrid level={1} width={10} height={15} shapes={getRandomShapes(30)} />\n      {/* <TetrisGrid width={10} height={15} shapes={[line(), line(), square(), square(), square(), square(), square()]} /> */}\n      <Footer />\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { App } from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}